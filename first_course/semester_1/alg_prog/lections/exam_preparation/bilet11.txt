## АиП | Билет - 10 ##
1. Понятие рекурсии
2. Виды и характеристики

# Понятие рекурсии
>> Рекурсия - это метод программирования, при котором функция вызывает саму себя для решения подзадач, являющихся упрощенной версией исходной задачи.

# Пример рекурсивной функции:
``` Вычисление факториала
int factorial(int n)
{
    if (n == 0) return 1; // базовый случай
    return n * factorial(n - 1); // рекурсивный случай
}
```

# Виды рекурсии
1. Прямая рекурсия:
* Функция вызывает сама себя
``` Пример
void func()
{
    func();
}
```

2. Косвенная рекурсия 
* функция вызывает другую функцию, которая, в свою очередь вызывает исходную функцию.
``` Пример
void funcA()
{
    funcB();
}

void funcB
{
    funcA();
}
```

3. Хвостовая рекурсия
* Рекурсивный вызов является последней инструкцией функции. Хвостовая рекурсия оптимизируется компилятором, превращаясь в цикл.
``` Пример
void printNumbers(int n)
{
    if (n == 0) return; // базовый случай
    printf("%d\n", n);
    printNumbers(n - 1);
}
```

4. Нестандартная рекурсия (два вызова и более)

* Характеристики рекурсии:
1. Базовый случай (условие выхода)
* Рекурсия должна завершаться, когда достигается определенное условие. Без базового случая возникает бесконечный цикл.
2. Рекурсивный случай:
* Содержит вызов функции с упрощенным аргументом.
3. Глубина рекурсии:
* Количество вложенных вызовов функции. Может быть ограничено системными настройками (например, стеком вызовов)
4. Стек вызовов:
* для каждой функции выделяется место в стеке памяти. Рекурсия использует стек вызовов для хранения текущих параметров, что делает ее ресурсоемкой

Преимущества и недостатки рекурсии
Преимущества:

Упрощает реализацию сложных задач (обход дерева, вычисление факториалов, поиск в лабиринте).
Позволяет выразить алгоритмы более компактно.
Недостатки:

Рекурсия может быть медленнее итерации из-за затрат на стек вызовов.
Возможность переполнения стека при глубокой рекурсии.

Примеры задач, решаемых рекурсией
Вычисление чисел Фибоначчи.
Обход графов (DFS).
Быстрая сортировка (QuickSort).
Обход дерева (Preorder, Inorder, Postorder).
Рекомендации:
Использовать рекурсию для задач с естественной деревовидной структурой.
Для задач с большим числом итераций предпочитать итеративный подход или оптимизировать хвостовую рекурсию.